/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "func.h"
#include <unistd.h>
#include <sys/types.h>  // for pid_t
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <vector>
#include <string>

/* Socket header files */
#include <sys/types.h>   
#include <sys/socket.h>
#include <netdb.h>

#include <netinet/in.h>
#include <arpa/inet.h>

/* These variables are created using the command line arguments in func_svc.cpp */
extern char* loggerIP;
extern char* portNumber;

#define READ_FD 0
#define WRITE_FD 1
/* Throughout this file, NULL is returned for the erroneous cases (It is handled by the client-side.) */
char **
func_1_svc(S *argp, struct svc_req *rqstp)
{   

	static char * result;
    std::string toLogger = "";  // string that will be sent to the logger
	const char* executable = argp->c;  // result will be written to output in client-side
	pid_t childpid;

    int p2c[2];
    int c2pSTDOUT[2];
    int c2pSTDERR[2];

    /* Create pipes and fork. */
    if(pipe(p2c) < 0 || pipe(c2pSTDOUT) < 0 || pipe(c2pSTDERR)<0|| (childpid = fork()) == -1) {  
        perror("Error in initalization.");
        return NULL;
    }; 

	if(childpid > 0) {
        int num1 = argp->a;
        int num2 = argp->b;
        char ptr[] = "";
		std::vector<char> vec;

        close(p2c[READ_FD]);         // parent won't read from parent-to-child
        close(c2pSTDOUT[WRITE_FD]);  // parent won't write to child-to-parent STDOUT
        close(c2pSTDERR[WRITE_FD]);  // parent won't write to child-to-parent STDERR

        /* Give the input to the child process for the blackbox */
		std::string str = std::to_string(num1) + " " + std::to_string(num2); 
        if(write(p2c[WRITE_FD], str.c_str(), str.size() + 1) == -1) {
            perror("Error while writing to child.");
            return NULL;
        }
        toLogger += str + " ";

        std::string out = "";

        /* Read the pipes byte by byte*/
        if(read(c2pSTDOUT[READ_FD], ptr, 1) > 0) { 
            vec.push_back(ptr[0]);
            while(read(c2pSTDOUT[READ_FD], ptr, 1) > 0) vec.push_back(ptr[0]);
			out = "SUCCESS:\n";
            std::string st(vec.begin(), vec.end());
            toLogger += st;
        }  else {
            if(read(c2pSTDERR[READ_FD], ptr, 1) == -1) {
                perror("Output is neither in STDOUT nor in STDERR.");
                return NULL;
            }
            vec.push_back(ptr[0]);
            while(read(c2pSTDERR[READ_FD], ptr, 1) > 0) vec.push_back(ptr[0]);
			out = "FAIL:\n";
            toLogger += "_\n";
        }

        
		/* Convert vec to string */
        std::string st(vec.begin(), vec.end());
        /* Concatenate the strings */
		std::string res = out + st;

        /* Allocate necessary memory to result and copy the string into it. */
        result = (char*) malloc((res.length()+1)*sizeof(char));
        strcpy(result, res.c_str());

        // close the ends of the pipes
        close(p2c[WRITE_FD]);
        close(c2pSTDERR[READ_FD]);
        close(c2pSTDOUT[READ_FD]);


    } else { // child process
        dup2(p2c[READ_FD], STDIN_FILENO);          // stdin - read from parent
        dup2(c2pSTDOUT[WRITE_FD], STDOUT_FILENO);  // stdout - write into the parent
        dup2(c2pSTDERR[WRITE_FD], STDERR_FILENO);  // stderr - write into the parent

        /* Close all the endpoints of the pipes */
        close(c2pSTDERR[READ_FD]);
        close(c2pSTDERR[READ_FD]);
        close(c2pSTDOUT[READ_FD]);
        close(c2pSTDOUT[WRITE_FD]);
        close(p2c[READ_FD]);
        close(p2c[WRITE_FD]);

        // Blackbox either produces an output to stdout or gives error to stderr.
        execl(executable, "./blackbox", NULL);
    }

    /* Before returning result to the client side, we have to send the output to the logger file. 
    It is done via socket programming. */

    /* Creating a socket */
    int socketf;
    struct sockaddr_in address;
    struct hostent *server;
    char *IP;
    /* Socket is created, return NULL if you encounter with an error. */
    if((socketf = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        printf("Error occurred while creating the socket.");
        return NULL;
    }
    
    printf("look");
    /* Get the address using the IP. */
    server = gethostbyname(loggerIP);
    printf("found");
    if(server == NULL) {
        perror("Error occurred while getting the IP address");
        return NULL;
    }
    
    /* Allocate memory for the address. */
    memset((char *) &address, 0, sizeof(address));
    memcpy((char *) server->h_addr_list[0], (char *) &address.sin_addr.s_addr, server->h_length);
    address.sin_family = AF_INET;
    address.sin_port = htons(atoi(portNumber));  // convert port number to integer
    address.sin_addr.s_addr = INADDR_ANY;
    
    /* Connect to the port */
    if (connect(socketf, (struct sockaddr *) &address, sizeof(address)) < 0) {
        perror("Error occurred while connecting to the socket.");
        return NULL;
    }

    /* Write to the port */
    if(write(socketf, toLogger.c_str(), toLogger.size()) < 0) {
        perror("Error occurred while writing to the logger.");
        return NULL; 
    }

    /* Close socket after finishing writing the data. */
    close(socketf);
	return &result;
}

