/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "func.h"
#include <unistd.h>
#include <sys/types.h>  // for pid_t
#include <string.h>
#include <vector>
#include <string>
#include <iostream>

/* Throughout this source code, for the erroneous cases, NULL is returned. (It is checked by the client side.)*/
#define READ_FD 0
#define WRITE_FD 1
char **
func_1_svc(S *argp, struct svc_req *rqstp)
{
	static char* result;
	
	const char* executable = argp->c;  // result will be written to output in client-side
	pid_t childpid;

    int p2c[2];
    int c2pSTDOUT[2];
    int c2pSTDERR[2];

    /* Create pipes and fork */
    if(pipe(p2c) < 0 || pipe(c2pSTDOUT) < 0 || pipe(c2pSTDERR)<0|| (childpid = fork()) == -1) {  
        perror("Error in initalization.");
        return NULL;
    }; 
	if(childpid > 0) {
        /* Data will be read byte by byte and stored in a vector. Then vector will be converted to a string. */
        int num1 = argp->a;
        int num2 = argp->b;
        char ptr[] = "";
        std::vector<char> vec;

        close(p2c[READ_FD]);         // parent won't read from parent-to-child (only write to it)
        close(c2pSTDOUT[WRITE_FD]);  // parent won't write to child-to-parent STDOUT (only read from it)
        close(c2pSTDERR[WRITE_FD]);  // parent won't write to child-to-parent STDERR (only read from it)

        // Give the required inputs to the child process
		std::string str = std::to_string(num1) + " " + std::to_string(num2); 
        if(write(p2c[WRITE_FD], str.c_str(), str.size() + 1) == -1) {
            perror("Error while writing to child.");
            return NULL;
        }
        
        /* Read the data (same with part A) */
        std::string out = "";
        if(read(c2pSTDOUT[READ_FD], ptr, 1) > 0) {  
            vec.push_back(ptr[0]);
            while(read(c2pSTDOUT[READ_FD], ptr, 1) > 0) vec.push_back(ptr[0]);
			out = "SUCCESS:\n";
        }  else {
            if(read(c2pSTDERR[READ_FD], ptr, 1) == -1) {
                perror("Output is neither in STDOUT nor in STDERR.");
                return NULL;
            }
            vec.push_back(ptr[0]);
            while(read(c2pSTDERR[READ_FD], ptr, 1) > 0) vec.push_back(ptr[0]);
			out = "FAIL:\n";
        }

        /* Convert vec to string */
        std::string st(vec.begin(), vec.end());
        /* Concatenate the strings */
		std::string res = out + st;

        /* Allocate necessary memory to result and copy the string into it. */
        result = (char*) malloc((res.length()+1)*sizeof(char));
        strcpy(result, res.c_str());


        // close the ends of the pipes
        close(p2c[WRITE_FD]);
        close(c2pSTDERR[READ_FD]);
        close(c2pSTDOUT[READ_FD]);
        

    } else { // child process
        dup2(p2c[READ_FD], STDIN_FILENO);   // stdin - read from parent
        dup2(c2pSTDOUT[WRITE_FD], STDOUT_FILENO);  //  stdout - write into the parent
        dup2(c2pSTDERR[WRITE_FD], STDERR_FILENO);  // stderr - write into the parent

        /* Close all the endpoints. */
        close(c2pSTDERR[READ_FD]);
        close(c2pSTDERR[READ_FD]);
        close(c2pSTDOUT[READ_FD]);
        close(c2pSTDOUT[WRITE_FD]);
        close(p2c[READ_FD]);
        close(p2c[WRITE_FD]);

        // Blackbox either produces an output to stdout or gives error to stderr.
        execl(executable, "./blackbox", NULL);
    }

	return &result;
}
