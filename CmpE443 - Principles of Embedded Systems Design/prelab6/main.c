/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

typedef struct {
	volatile uint32_t MODER;
	volatile uint32_t OTYPER;
	volatile uint32_t OSPEEDR;
	volatile uint32_t PUPDR;
	volatile uint32_t IDR;
	volatile uint32_t ODR;
	volatile uint32_t BSRR;
	volatile uint32_t LCKR;
	volatile uint32_t AFR[2];
	volatile uint32_t BRR;
	uint32_t RESERVED;
	volatile uint32_t SECCFGR;
} GPIO_TypeDef;

typedef struct
{
  volatile uint32_t CR1;
  volatile uint32_t CR2;
  volatile uint32_t SMCR;
  volatile uint32_t DIER;
  volatile uint32_t SR;
  volatile uint32_t EGR;
  volatile uint32_t CCMR1;
  volatile uint32_t CCMR2;
  volatile uint32_t CCER;
  volatile uint32_t CNT;
  volatile uint32_t PSC;
  volatile uint32_t ARR;
  volatile uint32_t RCR;
  volatile uint32_t CCR1;
  volatile uint32_t CCR2;
  volatile uint32_t CCR3;
  volatile uint32_t CCR4;
  volatile uint32_t BDTR;
  volatile uint32_t DCR;
  volatile uint32_t DMAR;
  volatile uint32_t OR1;
  volatile uint32_t CCMR3;
  volatile uint32_t CCR5;
  volatile uint32_t CCR6;
  volatile uint32_t OR2;
  volatile uint32_t OR3;
} TIM_TypeDef;

uint32_t wait_milisecond = 1000;
uint32_t wait_counter = 0;
uint32_t timer_value = 0;

#define RCC_AHB2ENR *((volatile uint32_t *) (0x40021000 + 0x4C))
#define RCC_APB2ENR *((volatile uint32_t *) (0x40021000 + 0x60))

#define GPIOA			((GPIO_TypeDef *)	0x42020000)
#define TIM16           ((TIM_TypeDef *)	0x40014400)

int main(void) {
	RCC_AHB2ENR |= 1 << 0;

	GPIOA->MODER &= ~(0x03 << (9 * 2));
	GPIOA->MODER |= (0x01 << (9 * 2));

	RCC_APB2ENR |= 1 << 17;
	TIM16->PSC = 4000 - 1;
	TIM16->CR1 |= (0x01);

	while(1) {
		timer_value = TIM16->CNT;
		while(TIM16->CNT - timer_value < wait_milisecond);

		GPIOA->BSRR = 1 << 9;
		wait_counter = wait_counter + 1;

		timer_value = TIM16->CNT;
		while(TIM16->CNT - timer_value < wait_milisecond);

		GPIOA->BSRR = 1 << (9 + 16);
		wait_counter = wait_counter + 1;

	}
}
