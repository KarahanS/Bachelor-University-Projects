/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

typedef struct {
	volatile uint32_t MODER;
	volatile uint32_t OTYPER;
	volatile uint32_t OSPEEDR;
	volatile uint32_t PUPDR;
	volatile uint32_t IDR;
	volatile uint32_t ODR;
	volatile uint32_t BSRR;
	volatile uint32_t LCKR;
	volatile uint32_t AFRL;
	volatile uint32_t AFRH;
	volatile uint32_t BRR;
	uint32_t RESERVED;
	volatile uint32_t SECCFGR;
} GPIO_TypeDef;

typedef struct {
  volatile uint32_t CR1;
  volatile uint32_t CR2;
  volatile uint32_t SMCR;
  volatile uint32_t DIER;
  volatile uint32_t SR;
  volatile uint32_t EGR;
  volatile uint32_t CCMR1;
  volatile uint32_t CCMR2;
  volatile uint32_t CCER;
  volatile uint32_t CNT;
  volatile uint32_t PSC;
  volatile uint32_t ARR;
  volatile uint32_t RCR;
  volatile uint32_t CCR1;
  volatile uint32_t CCR2;
  volatile uint32_t CCR3;
  volatile uint32_t CCR4;
  volatile uint32_t BDTR;
  volatile uint32_t DCR;
  volatile uint32_t DMAR;
  volatile uint32_t OR1;
  volatile uint32_t CCMR3;
  volatile uint32_t CCR5;
  volatile uint32_t CCR6;
  volatile uint32_t OR2;
  volatile uint32_t OR3;
} TIM_TypeDef;

typedef struct {
  volatile uint32_t ISER0;
  volatile uint32_t ISER1;
  volatile uint32_t ISER2;
  volatile uint32_t ISER3;
  volatile uint32_t ISER4;
  volatile uint32_t ISER5;
  volatile uint32_t ISER6;
  volatile uint32_t ISER7;
  volatile uint32_t ISER8;
  volatile uint32_t ISER9;
  volatile uint32_t ISER10;
  volatile uint32_t ISER11;
  volatile uint32_t ISER12;
  volatile uint32_t ISER13;
  volatile uint32_t ISER14;
  volatile uint32_t ISER15;
} NVIC_ISER_TypeDef;

typedef struct {
  volatile uint32_t ICER0;
  volatile uint32_t ICER1;
  volatile uint32_t ICER2;
  volatile uint32_t ICER3;
  volatile uint32_t ICER4;
  volatile uint32_t ICER5;
  volatile uint32_t ICER6;
  volatile uint32_t ICER7;
  volatile uint32_t ICER8;
  volatile uint32_t ICER9;
  volatile uint32_t ICER10;
  volatile uint32_t ICER11;
  volatile uint32_t ICER12;
  volatile uint32_t ICER13;
  volatile uint32_t ICER14;
  volatile uint32_t ICER15;
} NVIC_ICER_TypeDef;

#define NVIC_ISER ((NVIC_ISER_TypeDef *) 0xE000E100)
#define NVIC_ICER ((NVIC_ISER_TypeDef *) (0xE000E180))

#define RCC_AHB2ENR  *((volatile uint32_t *) (0x40021000 + 0x4C))
#define RCC_APB1ENR1 *((volatile uint32_t *) (0x40021000 + 0x058))
#define RCC_APB2ENR  *((volatile uint32_t *) (0x40021000 + 0x060))

#define GPIOA			((GPIO_TypeDef *) 0x42020000)

#define TIM15 ((TIM_TypeDef *)	0x40014000) // found in page 90-91
#define TIM16 ((TIM_TypeDef *)	0x40014400)
#define TIM1  ((TIM_TypeDef *)  0x40012C00)
// TIM15 - 69 in vector table -->  ISER2 5. bit
// TIM16 - 70 --> ISER2 6.bit

/* Timer dependent settings:
 * TIM_TypeDef creation with the corresponding address
 * Enabling the corresponding RCC register
 * IRQ Setting (ISER) --> vector table
 *
 * Don't forget: Hardware automatically clears the capture flag CCIF when CCR is read
 * However, you have to deal with SR if UIF is also enabled
 */


#define HI 1
#define LO 0
static uint16_t off = 0, on = 0;
static uint16_t period;
static unsigned int ic_pin = HI;
static unsigned int not_initialized = 1;

void init_TIM16()
{
	RCC_APB2ENR |= 1 << 17;  	// TIM15x_CLK is enabled, running at 4MHz
	TIM16->PSC = 20000 - 1;   	// milliseconds - increase for every 5 milliseconds
	TIM16->SR=0; 			 	// clear UIF if it is set (it should be disabled but let's make sure)
	TIM16->DIER |= 1 << 1;   	// enable CC1IE (capture/compare 1 interrupt enable
	NVIC_ISER->ISER2 |= 1 << 6; // enable global signaling for TIM16 interrupt - Interrupt Request (IRQ)

	TIM16->CCR1 = period;           // ontime
	TIM16->CCMR1 &= ~(11);        // CC1 Channel is configured as output mode
	TIM16->CCMR1 |= 0b11 << 4;    // 0b11: Toggle - OC1REF toggles (1 to 0 or 0 to 1) when TIMx_CNT=TIMx_CCR1.
	TIM16->CCER  |= 1;            // OC1 signal is output on the corresponding output pin
	TIM16->BDTR  |= 1 << 15;      // OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)

	TIM16->CR1   |= 1;            // TIM16_CNT is enabled
	not_initialized = 0;
}

void TIM16_IRQHandler(void)
{
	TIM16->CR1   &= ~1;
	TIM16->SR &= ~(1 << 1);

	if(period < 50) period = 50;
	if(period > 1000) period = 1000;
	TIM16->CCR1 = ((period * 2)/5);
	TIM16->CNT = 0;
	TIM16->CR1   |= 1;
}

void init_TIM15()
{
	// Don't modify SR
	RCC_APB2ENR |= 1 << 16;   	// TIM15x_CLK is enabled, running at 4MHz
	TIM15->PSC = 8000 - 1;    	// milliseconds - increase for every 2 milliseconds (0.5 KHz : 2 ms)
	TIM15->SR=0; 			  	// clear UIF if it is set
	TIM15->DIER |= 1 << 1;    	// enable CC1IE (capture/compare 1 interrupt enable)
	NVIC_ISER->ISER2 |= 1 << 5; //enable global signaling for TIM15 interrupt - Interrupt Request (IRQ)

	TIM15->CCMR1 |= 1;        	// CC1 channel is configured as input, IC1 is mapped on TI1
	TIM15->CCER |= 1;         	// Capture mode enabled
	TIM15->CCER |= 0b1010;   	// both edges : CC1NP = 1,  CC1P = 1
	TIM15->CR1 |= 1;          	// TIM15_CNT is enabled (clocked)
}

void TIM15_IRQHandler(void)
{
	if(ic_pin==LO) { // from off to on
		ic_pin=HI;
		uint16_t ccr = TIM15->CCR1;
		on = ccr;
		period = on - off;
	 } else {
		 ic_pin=LO; // from on to off
		 uint16_t ccr = TIM15->CCR1;
		 off = ccr;
		 period = off - on;
	 }
	if(not_initialized) init_TIM16();
}

// PA6 = Output Pin (RGB LED)
// PA2 = Input Pin
// We'll use PA2 as an input pin to understand if switch is on left, or on right.

/*
 * When the switch is on right, it is connected to ground - Current will go through the resistor - therefore input pin will take 1.
 * When the switch is on left, it is connected to voltage - Current will go through the resistor - therefore input pin will take 0.
 */
/*
 * To disable a timer:
 * 1) Disable global signaling for the peripheral (Set related m bit in ICERn)
 * 2) Donâ€™t clear UIF bit (SR register)
 * 3) Clear UIE in DIER (Update interrupt enable)
 * 4) Disable all interrupts (PRIMASK = 0)
 */

int main(void) {
	RCC_AHB2ENR |= 0b1;  // open port A

	GPIOA->MODER &= ~(1 << 4);   // pin 2 (5, 4   --> 1, 0)     PA2 alternate function (switch)
	GPIOA->MODER &= ~(1 << 12);   // pin 6 (13, 12   --> 1, 0)  PA6 general purpose output mode

	GPIOA->AFRL |= 0b1110 << (4 * 2);   // PA2 AF14: 1110
	GPIOA->AFRL |= 0b1110 << (4 * 6);   // PA6 AF14: 1110

	init_TIM15();

	// Write 0 to PRIMASK to enable global interrupts
	__asm volatile(
		"mov r0, #0 \n\t"
		"msr primask, r0 \n\t");

	while(1){
		__asm volatile("wfi");
	}
}
