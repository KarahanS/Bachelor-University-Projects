/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

typedef struct {
	volatile uint32_t MODER;
	volatile uint32_t OTYPER;
	volatile uint32_t OSPEEDR;
	volatile uint32_t PUPDR;
	volatile uint32_t IDR;
	volatile uint32_t ODR;
	volatile uint32_t BSRR;
	volatile uint32_t LCKR;
	volatile uint32_t AFR[2];
	volatile uint32_t BRR;
	uint32_t RESERVED;
	volatile uint32_t SECCFGR;
} GPIO_TypeDef;

typedef struct {
  volatile uint32_t CR1;
  volatile uint32_t CR2;
  volatile uint32_t SMCR;
  volatile uint32_t DIER;
  volatile uint32_t SR;
  volatile uint32_t EGR;
  volatile uint32_t CCMR1;
  volatile uint32_t CCMR2;
  volatile uint32_t CCER;
  volatile uint32_t CNT;
  volatile uint32_t PSC;
  volatile uint32_t ARR;
  volatile uint32_t RCR;
  volatile uint32_t CCR1;
  volatile uint32_t CCR2;
  volatile uint32_t CCR3;
  volatile uint32_t CCR4;
  volatile uint32_t BDTR;
  volatile uint32_t DCR;
  volatile uint32_t DMAR;
  volatile uint32_t OR1;
  volatile uint32_t CCMR3;
  volatile uint32_t CCR5;
  volatile uint32_t CCR6;
  volatile uint32_t OR2;
  volatile uint32_t OR3;
} TIM_TypeDef;

#define RCC_AHB2ENR  *((volatile uint32_t *) (0x40021000 + 0x4C))
#define RCC_APB1ENR1 *((volatile uint32_t *) (0x40021000 + 0x058))
#define RCC_APB2ENR  *((volatile uint32_t *) (0x40021000 + 0x060))

// #define GPIOA			((GPIO_TypeDef *) 0x42020000)
// #define GPIOB 			((GPIO_TypeDef *) 0x42020400)
#define GPIOD  			((GPIO_TypeDef *) 0x42020C00)  // PD3, PD4, PD5

#define TIM6  ((TIM_TypeDef *)	0x40001000)
#define TIM7  ((TIM_TypeDef *)	0x40001400)
#define TIM16 ((TIM_TypeDef *)	0x40014400)
#define TIM17 ((TIM_TypeDef *)	0x40014800)

#define ISER0 *((volatile uint32_t *) (0xE000E100))
#define ISER1 *((volatile uint32_t *) (0xE000E104))
#define ISER2 *((volatile uint32_t *) (0xE000E108))
#define ISER3 *((volatile uint32_t *) (0xE000E10C))
uint8_t cnt = 0;

void redOn() { GPIOD->BSRR = 1 << (3 + 16);}
void redOff() {GPIOD->BSRR = 1 << 3;}
void greenOn() {GPIOD->BSRR = 1 << (4 + 16);}
void greenOff() {GPIOD->BSRR = 1 << 4;}
void blueOn() {GPIOD->BSRR = 1 << (5 + 16);}
void blueOff() {GPIOD->BSRR = 1 << 5;}

// ON-OFF booleans
uint8_t R = 0;
uint8_t G = 0;
uint8_t B = 0;

// UIF: Update Interrupt Flag

void init_TIM6()
{
	RCC_APB1ENR1 |= 1 << 4;    // TIM6x_CLK is enabled, running at 4MHz
	TIM6->PSC = 4000 - 1;      // default: 4MHz - divide it by 4000 --> 1 KHz --> 1e3 cycles per second --> 1 cycle per millisecond
	TIM6->SR=0; 			   // clear UIF if it is set
	TIM6->DIER |= 1; 		   // enable UIF to generate an interrupt
	TIM6->CR1 &= ~(1<<1);      // OVF will generate an event
	TIM6->ARR = 10 - 1;
	ISER1 |= 1 << 17;		   //enable global signaling for TIM6 interrupt
	TIM6->CR1 |= 1;            // TIM6_CNT is enabled (clocked)
}
void TIM6_IRQHandler(void)
{
 if(cnt == 0 || cnt == 2 || cnt == 4|| cnt == 6) {
	 if(R) redOff();
	 else redOn();
	 R = 1 - R;
 } else redOff();
 TIM6->SR=0; //clear UIF
}

void init_TIM7()
{
	RCC_APB1ENR1 |= 1 << 5;  // TIM7x_CLK is enabled, running at 4MHz
	TIM7->PSC = 4000 - 1;
	TIM7->SR=0; 			 // clear UIF (update interrupt flag) if it is set
	TIM7->DIER |= 1;	 	 // enable UIF to generate an interrupt
	TIM7->CR1 &= ~(1<<1);    // OVF will generate an event
	TIM7->ARR = 5 - 1;
	ISER1 |= 1 << 18;        //enable global signaling for TIM7 interrupt
	TIM7->CR1 |= 1;          // TIM7_CNT is enabled (clocked)
}
void TIM7_IRQHandler(void)
{
if(cnt == 0 || cnt == 1 || cnt == 4 || cnt == 5) {
	if(G) greenOff();
	else greenOn();
	G = 1 - G;
} else greenOff();

 TIM7->SR=0; //clear UIF
}

void init_TIM16()
{
	RCC_APB2ENR |= 1 << 17;  // TIM16x_CLK is enabled, running at 4MHz
	TIM16->PSC = 4000 - 1;   // milliseconds
	TIM16->SR=0; 			 // clear UIF if it is set
	TIM16->DIER |= 1; 		 // enable UIF to generate an interrupt
	TIM16->CR1 &= ~(1<<1);   // OVF will generate an event
	TIM16->ARR = 3 - 1;
	ISER2 |= 1 << 6;   //enable global signaling for TIM16 interrupt
	TIM16->CR1 |= 1;         // TIM16_CNT is enabled (clocked)
}
void TIM16_IRQHandler(void)
{
 if(cnt == 0 || cnt == 1 || cnt == 2 || cnt == 3) {
	 if(B) blueOff();
	 else blueOn();
	 B = 1 - B;
 } else blueOff();
 TIM16->SR=0; //clear UIF
}

// colors:
/**
 * 0: white    RGB
 * 1: cyan     GB
 * 2: magenta  RB
 * 3: blue     B
 * 4: yellow   RG
 * 5: green    G
 * 6: red      R
 * 7: black
 */

void init_TIM17()
{
	RCC_APB2ENR |= 1 << 18;  // TIM17x_CLK is enabled, running at 4MHz
	TIM17->PSC = 4000 - 1;
	TIM17->SR=0;  			 // clear UIF if it is set
	TIM17->DIER |= 1; 	 	 // enable UIF to generate an interrupt
	TIM17->CR1 &= ~(1<<1);   // OVF will generate an event - set UDIS bit to 0
	TIM17->ARR = 999;
	ISER2 |= 1 << 7;   //enable global signaling for TIM17 interrupt
	TIM17->CR1 |= 1;         // TIM17_CNT is enabled (clocked)
}
void TIM17_IRQHandler(void)
{
 cnt = (cnt + 1) % 8;
 TIM17->SR=0; //clear UIF
}


int main(void) {
	RCC_AHB2ENR |= 0b1000;  // open port D

	// RED: PD3
	// GREEN: PD4
	// BLUE: PD5

	//Configure PD3, PD4, PD5 as General purpose output mode
	GPIOD->MODER &= ~(1 << 7);   // pin 3 (7, 6   --> 0, 1)
	GPIOD->MODER &= ~(1 << 9);   // pin 4 (9, 8   --> 0, 1)
	GPIOD->MODER &= ~(1 << 11);  // pin 5 (11, 10 --> 0, 1)

	init_TIM6();
	init_TIM7();
	init_TIM16();
	init_TIM17();

	// Write 0 to PRIMASK to enable all interrupts
	__asm volatile(
		"mov r0, #0 \n\t"
		"msr primask, r0 \n\t");
	 while(1);
}
